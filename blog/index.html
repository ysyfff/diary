<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · 日记</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="The Diary of Shiyong Yin"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · 日记"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/diary/index.html"/><meta property="og:description" content="The Diary of Shiyong Yin"/><meta property="og:image" content="https://your-docusaurus-test-site.com/diary/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://your-docusaurus-test-site.com/diary/img/docusaurus.png"/><link rel="shortcut icon" href="/diary/img/favicon/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://your-docusaurus-test-site.com/diary/blog/atom.xml" title="日记 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://your-docusaurus-test-site.com/diary/blog/feed.xml" title="日记 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener("DOMContentLoaded", function(){
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/diary/css/main.css"/></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/diary/"><img class="logo" src="/diary/img/logo.svg" alt="日记"/><h2 class="headerTitleWithLogo">日记</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/diary/blog" target="_self">Diary</a></li><li class=""><a href="https://github.com/ysyfff/diary" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>All Blog Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">All Blog Posts</h3><ul><li class="navListItem"><a class="navItem" href="/diary/blog/2018/07/13/pi.html">树莓派</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/26/layout.html">布局</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/25/module.html">模块化</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/25/attack.html">攻击与安全</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/25/async.html">异步</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/25/todo.html">TODO</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/24/React State.html">React状态管理比较</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/23/performance.html">性能优化</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/23/http.html">HTTP杂记</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/23/change-and-detection.html">(译)JS中数据的改变与发现</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/22/css.html">CSS杂记</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/20/xml-svg.html">XML与SVG</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/16/CV.html">个人简历</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/14/workspaces.html">Workspaces是什么</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/12/local-test-npm-package.html">NPM包测试之低高级策略</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/08/version.html">谈谈version</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/07/thin.html">减肥之道</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/07/problem.html">问题汇总</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/07/nginx-config.html">一个nginx配置</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/07/good-tool.html">好用的工具</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/07/good-npm.html">好用的npm包</a></li><li class="navListItem"><a class="navItem" href="/diary/blog/2018/06/06/framework.html">流行框架学习对比</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/07/13/pi.html">树莓派</a></h1><p class="post-meta">July 13, 2018</p><div class="authorBlock"></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="购物清单"></a><a href="#购物清单" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>购物清单</h2>
<ul>
<li>继电器 3</li>
<li>二极管 3</li>
<li>红外感应器 3</li>
<li>面包板 1</li>
<li>连接线 公母头 若干</li>
<li>270欧姆的电阻（若干）</li>
<li>光线传感器</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="配置pi"></a><a href="#配置pi" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置pi</h2>
<pre><code class="hljs">sudo raspi-<span class="hljs-built_in">config</span>
</code></pre>
<p>这里的配置很丰富呢，比如网络配置，比如启动模式配置等等，都可以在这里设置</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/26/layout.html">布局</a></h1><p class="post-meta">June 26, 2018</p><div class="authorBlock"></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="固定布局"></a><a href="#固定布局" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>固定布局</h2>
<p><strong>所有尺寸一律使用px</strong></p>
<ul>
<li>优点：简单，无兼容性问题</li>
<li>缺点：不能根据不同屏幕尺寸，有不同的表现</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="移动端也可采用固定布局"></a><a href="#移动端也可采用固定布局" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>移动端也可采用固定布局</h3>
<p>有两种方式</p>
<ol>
<li>viewport width 320 + initial-scale
<ul>
<li>在viewport meta标签上设置width=320，页面的各个元素也采用px作为单位。</li>
<li>通过用JS动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。</li>
</ul></li>
<li>viewport width 640 + user-scale=no
<ul>
<li>页面的各个元素也采用px作为单位</li>
<li>由于640px超出了手机宽度，浏览器会自动缩小页面至刚好全屏</li>
</ul></li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="viewport"></a><a href="#viewport" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>viewport</h3>
<p><strong>手机浏览器</strong>是把页面放在一个虚拟的&quot;窗口&quot;（viewport）中，通常这个虚拟的&quot;窗口&quot;（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。</p>
<pre><code class="hljs css languages- html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=640, initial-scale=1.0, user-scale=no"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<ul>
<li><strong>width</strong> 控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）</li>
<li><strong>height</strong> 和 width 相对应，指定高度</li>
<li><strong>initial-scale</strong> 初始缩放比例，也即是当页面第一次 load 的时候缩放比例</li>
<li><strong>maximum-scale</strong> 允许用户缩放到的最大比例</li>
<li><strong>minimum-scale</strong> 允许用户缩放到的最小比例</li>
<li><strong>user-scalable</strong> 用户是否可以手动缩放</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="流式布局"></a><a href="#流式布局" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>流式布局</h2>
<p><strong>网页中主要的划分区域的尺寸使用百分数（搭配min-<em>、max-</em>属性使用），例如，设置网页主体的宽度为80%，min-width为960px</strong></p>
<p>这种布局缺点明显：宽度使用百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。</p>
<h2><a class="anchor" aria-hidden="true" id="弹性布局"></a><a href="#弹性布局" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>弹性布局</h2>
<p><strong>包裹文字的各元素的尺寸采用em做单位，而页面的主要划分区域的尺寸仍使用百分数或px做单位（同「流式布局」或「固定布局」）</strong></p>
<p>CSS编写者常常把body元素的font-size设置为62.5%（浏览器默认字体大小16px*62.5%=10px），这样1em便是10px，方便了计算。</p>
<p><strong>使用了rem单位的弹性布局在移动端也很受欢迎。</strong></p>
<p><strong>其实，使用vw、vh等后起之秀的单位，可以实现完美的流式布局（高度和文字大小都可以变得“流式”），弹性布局就不再必要了。</strong></p>
<h2><a class="anchor" aria-hidden="true" id="响应式布局"></a><a href="#响应式布局" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>响应式布局</h2>
<p>随着CSS3出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出令人满意的效果，对CSS编写者而言，在实现上不拘泥于具体手法，</p>
<p><strong>但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。</strong></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/25/module.html">模块化</a></h1><p class="post-meta">June 25, 2018</p><div class="authorBlock"><p class="post-authorName"><a target="_blank" rel="noreferrer noopener">Shiyong Yin</a></p></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="无模块化的时代"></a><a href="#无模块化的时代" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>无模块化的时代</h2>
<blockquote>
<p>开始的开始，我们都是孩子。</p>
</blockquote>
<p>最开始是没有模块化这一说的，都是script标签异步引入。</p>
<h2><a class="anchor" aria-hidden="true" id="commonjs"></a><a href="#commonjs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CommonJS</h2>
<p>服务端的JavaScript——Nodejs使用了CommonJS并将其发扬光大，这标志着JavaScript模块化正式登上历史的舞台。</p>
<ol>
<li>定义模块
<ul>
<li>每个文件就是一个模块，每个模块都是一个单独的作用域</li>
</ul></li>
<li>模块输出
<ul>
<li>模块只有一个出口module.exports</li>
</ul></li>
<li>加载模块
<ul>
<li>require('lodash')</li>
</ul></li>
</ol>
<blockquote>
<p>我们发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。
这在服务器端实现很简单，也很自然，然而， 想在浏览器端实现问题却很多。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="amd"></a><a href="#amd" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AMD</h2>
<blockquote>
<p>Asynchronous Module Definition</p>
</blockquote>
<p>AMD规范的代表作就是requirejs。</p>
<p>requirejs解决了两个问题：</p>
<ol>
<li>多依赖问题——多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>
<li>阻塞问题——js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>
</ol>
<pre><code class="hljs css languages- js"><span class="hljs-comment">// 定义模块 myModule.js</span>
define([<span class="hljs-string">'dependency'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">'Byron'</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printName</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(name);
    }

    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">printName</span>: printName
    };
});

<span class="hljs-comment">// 加载模块</span>
<span class="hljs-built_in">require</span>([<span class="hljs-string">'myModule'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">my</span>)</span>{
　 my.printName();
});
</code></pre>
<p>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
<h2><a class="anchor" aria-hidden="true" id="cmd"></a><a href="#cmd" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CMD</h2>
<blockquote>
<p>Common Module Definition</p>
</blockquote>
<p>CMD规范的代表作就是seajs。</p>
<p>seajs解决的问题和requirejs是一样的。多依赖问题和阻塞问题。</p>
<pre><code class="hljs css languages- js"><span class="hljs-comment">// 定义模块  myModule.js</span>
define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>{
  <span class="hljs-keyword">var</span> $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery.js'</span>)
  $(<span class="hljs-string">'div'</span>).addClass(<span class="hljs-string">'active'</span>);
});

<span class="hljs-comment">// 加载模块</span>
seajs.use([<span class="hljs-string">'myModule.js'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">my</span>)</span>{

});
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="amd与cmd区别"></a><a href="#amd与cmd区别" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AMD与CMD区别</h2>
<p>下面的例子一目了然</p>
<pre><code class="hljs css languages- js"><span class="hljs-comment">/** AMD写法 **/</span>
define([<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"f"</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c, d, e, f</span>) </span>{ 
     <span class="hljs-comment">// 等于在最前面声明并初始化了要用到的所有模块</span>
    a.doSomething();
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) {
        <span class="hljs-comment">// 即便没用到某个模块 b，但 b 还是提前执行了</span>
        b.doSomething()
    } 
});

<span class="hljs-comment">/** CMD写法 **/</span>
define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>{
    <span class="hljs-keyword">var</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a'</span>); <span class="hljs-comment">//在需要时申明</span>
    a.doSomething();
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b'</span>);
        b.doSomething();
    }
});
</code></pre>
<p>最明显的区别是</p>
<ul>
<li>AMD依赖前置</li>
<li>CMD依赖就近</li>
</ul>
<p>AMD在模块加载完成后就会执行该模块，所有模块加载完成进入回调函数，执行主逻辑。
这个就导致了，依赖执行的顺序和加载的顺序不一致。完全取决于哪个先下载下来。</p>
<p>CMD加载摸个依赖后并不执行，只是下载而已。所有依赖加载完成后进入主逻辑，遇到require才执行
对应的模块，这样模块的执行顺序和书写顺序完全一致。</p>
<h2><a class="anchor" aria-hidden="true" id="es6-module"></a><a href="#es6-module" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES6 Module</h2>
<p>这个其实就是类似CommonJS了，同步的。</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/25/attack.html">攻击与安全</a></h1><p class="post-meta">June 25, 2018</p><div class="authorBlock"><p class="post-authorName"><a target="_blank" rel="noreferrer noopener">Shiyong Yin</a></p></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="xss"></a><a href="#xss" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>XSS</h2>
<h2><a class="anchor" aria-hidden="true" id="sql注入"></a><a href="#sql注入" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>SQL注入</h2>
<h2><a class="anchor" aria-hidden="true" id="csrf"></a><a href="#csrf" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>CSRF</h2>
<blockquote>
<p>Cross—Site Request Forgery(伪造)
跨站点请求伪造</p>
</blockquote>
<p>攻击过程</p>
<ol>
<li>A访问站点B，并登陆</li>
<li>B将cookie存于A的浏览器中</li>
<li>A在B站点登陆的情况下，访问站点C</li>
<li>站点C利用A在B站点登陆的状态，向A站点发送伪造请求，实施攻击</li>
</ol>
<p>防御方法</p>
<ol>
<li><p>HTTP Referer</p>
<p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a>，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。</p>
<p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。</p></li>
<li><p>token</p>
<p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。</p>
<blockquote>
<p>要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
</blockquote></li>
</ol>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/25/async.html">异步</a></h1><p class="post-meta">June 25, 2018</p><div class="authorBlock"><p class="post-authorName"><a target="_blank" rel="noreferrer noopener">Shiyong Yin</a></p></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="promise"></a><a href="#promise" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promise</h2>
<h2><a class="anchor" aria-hidden="true" id="异步习题"></a><a href="#异步习题" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步习题</h2>
<blockquote>
<p>为什么最后打印a end ? await会一直阻塞下去，直到线程中所有代码执行完毕？！</p>
</blockquote>
<pre><code class="hljs css languages- js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a start'</span>)
  <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> b();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a end'</span>);
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b start'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'c start'</span>)
  <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> d();
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'c end'</span>);
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">d</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'d start'</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>;
}
a();
c();
setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'tiemout'</span>)
}, <span class="hljs-number">0</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>);
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>);
  resolve()
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>);
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise3'</span>);
    resolve();
  }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise4'</span>);
  });
});

<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>)
</code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/25/todo.html">TODO</a></h1><p class="post-meta">June 25, 2018</p><div class="authorBlock"><p class="post-authorName"><a target="_blank" rel="noreferrer noopener">Shiyong Yin</a></p></div></header><article class="post-content"><div><span><ul>
<li>原型</li>
<li>异步</li>
</ul>
<ol>
<li>flex</li>
<li>throttle</li>
<li>bind</li>
<li>arguments</li>
<li>[]==false</li>
<li>动态规划</li>
<li>异步</li>
<li>let =&gt;</li>
</ol>
<p>回答的不好的</p>
<ul>
<li>https</li>
<li><del>csrf</del></li>
<li>vue react diff</li>
<li><del>amd cmd</del></li>
</ul>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/24/React State.html">React状态管理比较</a></h1><p class="post-meta">June 24, 2018</p><div class="authorBlock"></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="hd"></a><a href="#hd" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>hd</h2>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/23/performance.html">性能优化</a></h1><p class="post-meta">June 23, 2018</p><div class="authorBlock"><p class="post-authorName"><a target="_blank" rel="noreferrer noopener">Shiyong Yin</a></p></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="优化方法"></a><a href="#优化方法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化方法</h2>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/23/http.html">HTTP杂记</a></h1><p class="post-meta">June 23, 2018</p><div class="authorBlock"><p class="post-authorName"><a target="_blank" rel="noreferrer noopener">Shiyong Yin</a></p></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="http-caching"></a><a href="#http-caching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTP caching</h2>
<p>缓存的种类有很多，大致归为两类：私有与共享缓存。共享缓存能够被多个用户使用。本文主要介绍浏览器与代理缓存，除此之外还有网关
缓存，CDN，反向代理缓存，负载均衡器等部署在服务器上，为站点和web应用提供更好的稳定性、性能和扩展性。</p>
<h3><a class="anchor" aria-hidden="true" id="缓存控制"></a><a href="#缓存控制" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存控制</h3>
<h4><a class="anchor" aria-hidden="true" id="cache-control"></a><a href="#cache-control" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>cache-control</h4>
<p>HTTP/1.1定义的Cache-Control投用来区分对缓存机制的支持情况，<strong>请求头和响应头都支持这个属性。</strong>
通过它来定义缓存策略。</p>
<ul>
<li><p>禁止进行缓存</p>
<pre><code class="hljs css languages- http"><span class="hljs-attribute">Cache-Control</span>: no-store
</code></pre></li>
<li><p>强制确认缓存</p>
<pre><code class="hljs css languages- http"><span class="hljs-attribute">Cache-Control</span>: no-cache
</code></pre></li>
<li><p>私有和公共缓存</p>
<pre><code class="hljs css languages- http"><span class="hljs-attribute">Cache-Control</span>: private, public
</code></pre></li>
<li><p>缓存过期机制</p>
<p><code>max-age=&lt;seconds&gt;</code>相比Expires而言，max-age是距离请求发起的时间的秒数。针对应用中那些不会改变的文件
通常可以手动设置一定的时长以保证缓存有效，如图片、css、js等静态资源</p>
<pre><code class="hljs css languages- http"><span class="hljs-attribute">Cache-Control</span>: max-age=387488400
</code></pre></li>
<li><p>缓存验证确认</p>
<p>这就意味着在考虑使用一个陈旧的资源时，必须先验证她的状态，已过期的缓存将不被使用。</p>
<pre><code class="hljs css languages- http"><span class="hljs-attribute">Cache-Control</span>: must-revalidate
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="pragma头"></a><a href="#pragma头" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pragma头</h4>
<p>Pragma是HTTP/1.0标准中定义的一个header属性，只能用在头中。作用和cache-control：no-cache相同</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="新鲜度"></a><a href="#新鲜度" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>新鲜度</h3>
<h4><a class="anchor" aria-hidden="true" id="缓存驱逐"></a><a href="#缓存驱逐" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存驱逐</h4>
<p>理论上来讲，当一个资源被缓存存储后，改资源可以被永久存储在缓存中。由于缓存只有有限空间，所以将定期删除
以下副本，这个过程叫做<strong>缓存驱逐</strong>。</p>
<p>由于HTTP是C/S模式的协议，服务器更新一个资源时，不可能直接通知客户端及其缓存，所以双方必须为该资源约定
一个过期时间，在此之前是，该资源是新鲜的，在此之后就是陈旧的。</p>
<blockquote>
<p>一个陈旧的资源是不会被直接清楚或忽略的</p>
</blockquote>
<blockquote>
<p>更新旧资源的过程如下</p>
<ul>
<li>客户端发起请求，缓存检测到一个对应的旧资源</li>
<li>缓存将此请求附加一个<code>If-None-Match</code>头，发送给服务器
<ul>
<li>服务器返回304(该响应头不会带有实体信息)，表示此资源副本是新鲜的</li>
<li>服务器判断已过期，则返回带有实体内容</li>
</ul></li>
</ul>
</blockquote>
<p><svg width="500" height="400">
<path d="M 50 20 V 50 390" stroke="green" />
<text x="25" y="20" font-size="20" fill="blue">client</text>
<path d="M 250 20 V 150 390" stroke="green" />
<path d="M 450 20 V 250 390" stroke="green" />
</svg></p>
<p>对于含有特定头部信息的请求，会去计算缓存寿命。通常情况下</p>
<ol>
<li>看max-age</li>
<li>对于不含max-age这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效</li>
<li>如果Expires也没有，找着头里的Last-Modifyed信息。如果有，缓存的寿命就等于头里面的Date的值减去Last-Modified的值除以10</li>
</ol>
<h3><a class="anchor" aria-hidden="true" id="加速资源"></a><a href="#加速资源" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>加速资源</h3>
<p>不频繁跟新的文件会使用特停的命名方式：在URL后面(通常是文件名后面)会加上版本号。加上版本号后的资源被视作一个完全新的
独立的资源，同时拥有一年伸着更长的缓存过期时长。同时更新的时候不会法伤部分缓存先更新而引起新旧文件内容不一致的问题。</p>
<h3><a class="anchor" aria-hidden="true" id="缓存验证"></a><a href="#缓存验证" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存验证</h3>
<p>用户点击刷新按钮时开始缓存验证。</p>
<h4><a class="anchor" aria-hidden="true" id="etags"></a><a href="#etags" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ETags</h4>
<p>作为缓存的一种强校验器，ETags响应头是一个队用户代理不透明的值。如果资源请求的响应头里含有ETag，客户端可以在后续的
请求的头中带上If-None-match头来验证缓存。</p>
<p>Last-Modified响应头可以作为一种弱校验器。因为只能精确到一秒。如果响应头里有这个信息，客户端可以在后续的请求的头部带上
If-Modified-Since来做校验</p>
<h3><a class="anchor" aria-hidden="true" id="带vary头的响应"></a><a href="#带vary头的响应" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>带Vary头的响应</h3>
<pre><code class="hljs css languages- http"><span class="hljs-attribute">Vary</span>: User-Agent
</code></pre>
<p>当缓存服务器收到一个请求，只有当前的请求和原始的请求头跟缓存的响应头里的Vary都匹配才能使用缓存。</p>
<p>使用Vary头有利于内容服务的动态多样性。如果需要区分移动端和桌面端的展示内容，就可以使用Vary: User-Agent，避免在不同终端展示
错误的布局。</p>
<h2><a class="anchor" aria-hidden="true" id="expires"></a><a href="#expires" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Expires</h2>
<blockquote>
<p>GMT</p>
</blockquote>
<p>响应头包含日期/时间，即在此时候之后，响应过期。</p>
<p>无效的日期，比如0，代表过去的日期，即该资源已过期。</p>
<p>如果在Cache-Control中设置了max-age或者s-max-age指令，Expires会被忽略。</p>
<h2><a class="anchor" aria-hidden="true" id="date"></a><a href="#date" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Date</h2>
<blockquote>
<p>GMT</p>
</blockquote>
<p>Date是一个通用首部，其中包含了消息生成的日期和时间。</p>
<h2><a class="anchor" aria-hidden="true" id="last-modified"></a><a href="#last-modified" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Last-Modified</h2>
<blockquote>
<p>GMT</p>
</blockquote>
<p>Last-Modified是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。由于精度比ETag要低，
所以这是一个备用机制。包含有If-Modified-Since或If-Unmodifed-Since首部的条件求情会使用这个字段。</p>
<h2><a class="anchor" aria-hidden="true" id="etag"></a><a href="#etag" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ETag</h2>
<p>ETag 响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省贷款，因为如果内容没有变，web服务器
不需要发送完整的响应。如果变了，Etag能有防止资源的同时更新相互覆盖(&quot;空中碰撞&quot;)。</p>
<h3><a class="anchor" aria-hidden="true" id="避免-空中碰撞"></a><a href="#避免-空中碰撞" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>避免&quot;空中碰撞&quot;</h3>
<p>ETag与If-Match配合来检测到空中碰撞的编辑冲突</p>
<p>编辑内容是wiki被散列，放入Etag：</p>
<pre><code class="hljs css languages- http"><span class="hljs-attribute">Etag</span>: jdoiaj8383838392983ijaojdosdjiojsdij
</code></pre>
<p>将更改保存到wiki页面时，POST请求中包含有Etag值得If-Match头来检查是否为最新版本</p>
<h3><a class="anchor" aria-hidden="true" id="缓存为更改的资源"></a><a href="#缓存为更改的资源" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存为更改的资源</h3>
<p>原理上面已经讲到</p>
<h2><a class="anchor" aria-hidden="true" id="https"></a><a href="#https" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTPS</h2>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/diary/blog/2018/06/23/change-and-detection.html">(译)JS中数据的改变与发现</a></h1><p class="post-meta">June 23, 2018</p><div class="authorBlock"><p class="post-authorName"><a target="_blank" rel="noreferrer noopener">Shiyon Yin</a></p></div></header><article class="post-content"><div><span><p><a href="http://teropa.info/blog/2015/03/02/change-and-its-detection-in-javascript-frameworks.html">原文传送门</a></p>
<p>比较Angular,Ember,React,Backbone的角度有很多，但是也许比较他们是如何管理状态的角度是最有趣的。</p>
<h2><a class="anchor" aria-hidden="true" id="投影数据"></a><a href="#投影数据" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>投影数据</h2>
<p>我们可以理解为将我们的数据投影到屏幕上的。比如JS中的对象，数组，字符串是源头，HTML中的forms，links，
buttons，images等是显示屏幕上的内容。</p>
<p>我们称之为渲染过程。我们可以认为是数据到可视化界面的投影。当我们根据数据渲染模板的时候，我们得到了代表了我们
数据的DOM(HTML)。</p>
<p><img src="/diary/img/onchange_base.svg" alt="onchange_base"></p>
<p>平常来说这是没有什么问题的。</p>
<p>假如数据随着时间的改变而改变的话，这就比较有挑战性了。比如用户的操作导致了数的变化，或者什么发生了什么改变了数据。
UI需要体现出这些变化。<strong>更重要的是，重新构建DOM是花费昂贵的。我们希望最小化的更新节点</strong></p>
<p><img src="/diary/img/onchange_change.svg" alt="onchange_change"></p>
<p>这可比只渲染一次UI困难多了，因为牵涉到了状态的变化。我们就从这里探讨上面框架的解决方案与不同之处。</p>
<h2><a class="anchor" aria-hidden="true" id="服务端渲染-重置全局"></a><a href="#服务端渲染-重置全局" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务端渲染：重置全局</h2>
<blockquote>
<p>没有改变，全局不可变</p>
</blockquote>
<p>在大JS的时代之前，每一个点击，没一个表单提交，都会将页面unload掉，从后端请求整个渲染的页面，回来之后，再次渲染。
这就是所谓的服务端渲染。</p>
<p><img src="/diary/img/onchange_reload.svg" alt="onchange_reload"></p>
<p>这种方法前端是不管理任何state的，都由后端处理，前端只是提供下html，css，或许有点点JS。</p>
<p>显而易见这种方法速度很慢</p>
<ol>
<li>UI需要全部渲染</li>
<li>需要走后端请求，一去一回要不少时间</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="第一代js-手动重新渲染"></a><a href="#第一代js-手动重新渲染" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>第一代JS：手动重新渲染</h2>
<blockquote>
<p>我不知道哪些应该重新渲染，你来搞明白</p>
</blockquote>
<p>总的来说，数据改变，发出事件，重新渲染UI你来决定。</p>
<p>第一代框架如backbone, ext, dojo第一次在浏览器中引入了data model，同时也是第一次
我们需要改变state在浏览器端。<strong>data model的内容改变之后需要你来获取改变然后改变UI</strong>.
<strong>数据改变的时候回触发一些事件</strong>，但是重新渲染UI是你的责任。</p>
<p><img src="/diary/img/onchange_manual.svg" alt="onchange_manual"></p>
<p>到底是渲染一大部分还是渲染一小部分就由你来决定了。灵活性很大，但同时不要忘了性能。</p>
<h2><a class="anchor" aria-hidden="true" id="手动重新渲染解决方案"></a><a href="#手动重新渲染解决方案" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>手动重新渲染解决方案</h2>
<h3><a class="anchor" aria-hidden="true" id="emberjs-数据绑定"></a><a href="#emberjs-数据绑定" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Ember.js：数据绑定</h3>
<blockquote>
<p>我知道什么变化了，也知道哪里需要重新渲染，因为我控制了model和view</p>
</blockquote>
<p>总的来说，通过我设计的API来控制Model</p>
<p>和backbone一样，Ember也会在数据改变的时候发出事件，不同的是，我们把UI绑定到data model上，
也就是说，有一个数据变化的监听器，在监听器里可以和UI做绑定。这个监听器知道在接收到数据变化的时候
如何更新UI。(我们可以通过watch来获得变化，并进行UI的绑定)</p>
<p><img src="/diary/img/onchange_kvo.svg" alt="onchange_kvo"></p>
<p><strong>最大的不好的地方是，Ember必须永远知道数据的变化，这就要求我们使用Ember设计的一套API。</strong></p>
<h3><a class="anchor" aria-hidden="true" id="angularjs-脏检查"></a><a href="#angularjs-脏检查" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>AngularJS：脏检查</h3>
<blockquote>
<p>我不知道什么发生了改变，所以我就检查下所有地方好了</p>
</blockquote>
<p>虽然AngularJS也在着手解决手动重新渲染的问题，但是它是从另一个角度解决问题的。</p>
<p>当我们通过angular模板渲染<code>{{foo.x}}</code>的时候，angular不仅渲染数据，还为这个特殊的值创建了的一个watcher，
从此以后，只要有变化，它就检查watcher中的值是否变了，如果变了就在UI中重新渲染这个值。整个过程就是脏检查。</p>
<p><img src="/diary/img/onchange_watch.svg" alt="onchange_watch"></p>
<p>不好的地方就是，当改变发生的时候，angular并没有深入的探测到具体是哪个数据发生了改变。所以，只要一有情况发生，
所有的watcher都要跑一遍。</p>
<p>听起来这是个性能的噩梦，但实际上还是挺快的，因为仅仅是纯JS的逻辑执行，没有牵涉到DOM的更新。但是当UI十分庞大的时候，
或者需要频繁渲染的时候，额外的优化技巧就是必须的了。</p>
<p>另外提一下，ES7中的Object.observe对Ember和Angular会十分有帮助，因为这给出了原生的watching在属性的改变上面。</p>
<h3><a class="anchor" aria-hidden="true" id="react-virtualdom"></a><a href="#react-virtualdom" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>React：VirtualDOM</h3>
<blockquote>
<p>我不知道发生了哪些改变，所以我就重新渲染下，看看与之前有什么不同</p>
</blockquote>
<p>React和Angular类似，不需要data modal API的支持。那么React是如何根据数据的变化来解决UI的更新的呢？</p>
<p>React好像将我们带到了服务端渲染的方式。React的做法是从头到尾的渲染了整个UI。</p>
<p>这听起来是低效的，如果这就是故事的结尾，那确实是。然而，React 用了特殊的方法进行重新渲染。</p>
<p>当React UI进行渲染的时候，它首先渲染到Virtual DOM里面，并不是真正的DOM，而是一个轻量级的，纯粹的对象和数组的
JavaScript数据结构，这个数据结构代表了真实的DOM对象图。然后一个单独的进程采用该DOM结构在屏幕上渲染出真实的DOM结构。</p>
<p><img src="/diary/img/onchange_vdom_initial.svg" alt="onchange_vdom_initial"></p>
<p>当数据改变的时候，一个新的Virtual DOM被从头的创建。新的Virtual DOM中包含了变化的值。React从这两个Virtual DOM执行
diff算法。来获取变化的地方。而且只有那些被改变的地方才会被真实DOM重新渲染。</p>
<p><img src="/diary/img/onchange_vdom_change.svg" alt="onchange_vdom_change"></p>
<h3><a class="anchor" aria-hidden="true" id="immutable-js"></a><a href="#immutable-js" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Immutable-js</h3>
<p>尽管React的Virtual DOM已经很快了，但是在UI很大或者需要频繁渲染的时候还是会出现瓶颈。</p>
<p>问题是真的没有方法能够渲染整个DOM，(UI太大渲染不过来，渲染太快，还没渲染完就需要渲染洗一次了)。除非想Ember一想引入
一套data model API。</p>
<p>一个有效的解决的方法就是使用immutable，这和React的Virtual DOM很般配。</p>
<p>immutable是这么一个原理。正如他的名字一样，你永远不能直接改变一个对象，当时我们可以基于这个对象产生一个新的版本。</p>
<p>使用immutable的意义就是，我们可以重复使用上次Virtual DOM的那些没有改变的Virtual DOM部分。</p>
<p><img src="/diary/img/onchange_immutable.svg" alt="onchange_immutable"></p>
<p>像Ember一样，我们不能使用原生JS对象，必须使用额外的API。但是不同点在于，这次并不是框架的需要，我们使用它因为这是一种
更好的管理state的方法。这不仅提高新性能，而且是一种文化的象征。</p>
<h2><a class="anchor" aria-hidden="true" id="总结"></a><a href="#总结" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>
<p>对改变的发现是UI渲染的核心问题，JS库通过各种各样的途径来解决这个问题。</p>
<p>EmberJS能够检测到变化，当他们发生的时候，因为EmberJS通过API控制了Model和View，当你调用他们的时候你可以触发事件。</p>
<p>AngularJS在变化之后去检测变化，通过re-running在UI中所有的绑定来看看值是否发生了改变。</p>
<p>纯React通过re-render whole UI到一个Virtual DOM然后和就得版本比较来获得改变。不管发生了什么，都补丁到真实DOM上。</p>
<p>有immutable的React加强了纯React，通过让component快速标记那些没有改变来提升速度，这是性能的选择，同时也是文化的选择。</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/diary/blog/page2/">Next →</a></div></div></div></div></div><footer class="nav-footer" id="footer"><a href="https://code.facebook.com/projects/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"></a><section class="copyright">Copyright © 2018-2018 Shiyong Yin</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: 'ab87fbb1dabfa3bd00662f0f793a313f',
                indexName: 'ysyfff',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>